<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Résultats - Hauts de Flandre Natation</title>
  <link rel="stylesheet" href="style.css">
  <style>
    .csv-table {
      border-collapse: collapse;
      width: 90%;
      max-width: 1200px;
      margin: 1.5em auto;
      background-color: #f9f9f9;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    }
    .csv-table th, .csv-table td {
      border: 1px solid #ccc;
      padding: 8px 10px;
      text-align: center;
    }
    .csv-table th {
      background-color: #0057b8;
      color: white;
    }
    .csv-table tr:nth-child(even) { background-color: #e6f0fa; }
    .csv-table tr:hover { background-color: #d0e4ff; }
    h2 { text-align: center; margin-top: 1.5em; }
    .small { font-size: 0.85em; color: #333; }
    .no-records { text-align:center; color:#666; margin:0.8em 0 1.5em 0; }
    @media (max-width: 900px) {
      .csv-table { width: 95%; font-size: 0.9em; }
    }
    /* un peu d'espacement pour sections */
    #recordsFemmes, #recordsHommes, #tableContainer { margin-bottom: 2em; }
  </style>
</head>
<body>
  <div id="header"></div>

  <main>
    <section class="intro-section">
      <h2>Résultats du club</h2>
      <p>
        Retrouvez ici les performances de nos nageurs, extraites des résultats officiels de la
        <a href="https://www.ffnatation.fr" target="_blank"><strong>Fédération Française de Natation (FFN)</strong></a>.
      </p>
    </section>

    <h2>Records Féminins</h2>
    <div id="recordsFemmes">Chargement...</div>

    <h2>Records Masculins</h2>
    <div id="recordsHommes">Chargement...</div>

    <h2>Tous les résultats</h2>
    <div id="tableContainer">Chargement des résultats...</div>
  </main>

  <footer id="footer"></footer>

  <!-- GoatCounter si besoin -->
  <script data-goatcounter="https://clubhautsdeflandrenatation.goatcounter.com/count"
          async src="https://gc.zgo.at/count.js"></script>

  <script>
  /* ---------------------------
     Fonctions utilitaires
     --------------------------- */

  // normalise texte : supprime accents, trim, minuscules
  function normalizeText(s) {
    if (s === undefined || s === null) return '';
    return String(s).trim()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      .toLowerCase();
  }

  // détecte si champ sexe correspond à féminin / masculin
  function normalizeSexFieldRaw(s) {
    const n = normalizeText(s);
    if (!n) return '';
    if (n.includes('fem') || n === 'f' || n.includes('femin')) return 'Feminin';
    if (n.includes('masc') || n.includes('hom') || n === 'm' || n.includes('masculin')) return 'Masculin';
    return s; // retourne brut si impossible
  }

  // convertit un temps texte en secondes (gère 1:23.45, 01:23,45, 83.45)
  function parseTimeToSeconds(t) {
    if (!t) return Infinity;
    const s = String(t).trim().replace(/\s/g,'').replace(',', '.');
    if (s === '') return Infinity;
    const parts = s.split(':').map(p => p.trim());
    if (parts.length === 1) {
      const v = parseFloat(parts[0]);
      return isNaN(v) ? Infinity : v;
    } else if (parts.length === 2) {
      const mins = parseFloat(parts[0]) || 0;
      const secs = parseFloat(parts[1]) || 0;
      return mins*60 + secs;
    } else if (parts.length === 3) {
      const h = parseFloat(parts[0]) || 0;
      const m = parseFloat(parts[1]) || 0;
      const sec = parseFloat(parts[2]) || 0;
      return h*3600 + m*60 + sec;
    }
    return Infinity;
  }

  // affiche texte en sécurité
  function safeText(t) { return (t === undefined || t === null) ? '' : String(t); }

  // normalisation d'en-tête pour trouver colonne par mot-clé
  function normHeaderKey(h) {
    return normalizeText(h).replace(/\s+/g,' ');
  }

  // trouve la première colonne dont l'entête contient un des mots-clés
  function findHeaderIndex(headersNorm, keywords) {
    for (let i=0;i<headersNorm.length;i++) {
      for (const k of keywords) {
        if (headersNorm[i].includes(k)) return i;
      }
    }
    return -1;
  }

  /* ---------------------------
     Charger header/footer (ton code)
     --------------------------- */
  fetch('header.html').then(r => r.text()).then(d => { document.getElementById('header').innerHTML = d; }).catch(()=>{});
  fetch('footer.html').then(r => r.text()).then(d => { document.getElementById('footer').innerHTML = d; }).catch(()=>{});

  /* ---------------------------
     Charger CSV et construire tableaux
     --------------------------- */
  fetch('data/resultats_csv.csv')
    .then(r => r.text())
    .then(text => {
      // split robust
      const rawLines = text.replace(/\r/g,'').split('\n').filter(l => l.trim() !== '');
      if (!rawLines.length) {
        document.getElementById('tableContainer').textContent = 'Fichier CSV vide ou introuvable.';
        return;
      }

      // en-tête et lignes
      const headers = rawLines[0].split(';').map(h => h.trim());
      const headersNorm = headers.map(h => normHeaderKey(h || ''));

      // Matrice de données (garantie longueur >= 9 pour éviter index undefined)
      const data = rawLines.slice(1).map(line => {
        const cols = line.split(';').map(c => c.trim());
        while (cols.length < 10) cols.push('');
        return cols;
      });

      // ---- détecter indices (essayer de s'appuyer sur les en-têtes)
      // mots clés probables (français / anglais)
      const idxEpreuve = findHeaderIndex(headersNorm, ['epreuve','epreuve','epreuve/','epreuve ' ,'epreuve','event','epreuve;']);
      const idxNom    = findHeaderIndex(headersNorm, ['nom prenom','nom','nageur','athlete','name']);
      const idxSexe   = findHeaderIndex(headersNorm, ['sexe','genre','sex','sex/genre']);
      const idxTemps  = findHeaderIndex(headersNorm, ['temps','time','chrono','result']);
      const idxCateg  = findHeaderIndex(headersNorm, ['categorie','categorie_age','cat','category','catégorie']);
      const idxDate   = findHeaderIndex(headersNorm, ['date']);
      const idxAnnee  = findHeaderIndex(headersNorm, ['annee','annee naissance','annee_naissance','annee de naissance','annee_naiss']);

      // fallback si non trouvé : utiliser indices usuels (1-based -> 0-based guessed)
      // Ces valeurs sont des "meilleures estimations" suivant ton description initiale.
      const fallback = {
        epreuve: 0,
        // on met sexe 2 (troisième colonne) seulement si detection a échoué
        sexe: 2,
        nom: 3,
        temps: 5,
        categorie: 8
      };

      const IDX_EPREUVE = idxEpreuve >= 0 ? idxEpreuve : fallback.epreuve;
      const IDX_NOM     = idxNom    >= 0 ? idxNom    : fallback.nom;
      const IDX_SEXE    = idxSexe   >= 0 ? idxSexe   : fallback.sexe;
      const IDX_TEMPS   = idxTemps  >= 0 ? idxTemps  : fallback.temps;
      const IDX_CATEG   = idxCateg  >= 0 ? idxCateg  : fallback.categorie;

      console.log('Colonnes détectées -> epreuve:', IDX_EPREUVE, 'nom:', IDX_NOM, 'sexe:', IDX_SEXE, 'temps:', IDX_TEMPS, 'categorie:', IDX_CATEG);

      // ---- construire TABLEAU GENERAL (avec filtres)
      let tableHTML = '<table id="resultsTable" class="csv-table"><thead><tr>';
      headers.forEach((h,i) => {
        const uniqueValues = [...new Set(data.map(row => safeText(row[i]) || ''))].filter(v => v !== '').sort();
        let selectHTML = `<select class="colFilter" data-col="${i}"><option value="">Tous</option>`;
        uniqueValues.forEach(val => selectHTML += `<option value="${val}">${val}</option>`);
        selectHTML += '</select>';
        tableHTML += `<th>${safeText(h)}<br>${selectHTML}</th>`;
      });
      tableHTML += '</tr></thead><tbody>';
      data.forEach(row => {
        tableHTML += '<tr>';
        for (let i=0;i<headers.length;i++) tableHTML += `<td>${safeText(row[i])}</td>`;
        tableHTML += '</tr>';
      });
      tableHTML += '</tbody></table>';
      document.getElementById('tableContainer').innerHTML = tableHTML;

      // ---- préparer listes d'épreuves et catégories (globales, pour cohérence horizontale)
      const epreuvesSet = new Set();
      const categoriesSet = new Set();
      data.forEach(row => {
        const e = safeText(row[IDX_EPREUVE]);
        const c = safeText(row[IDX_CATEG]) || '—';
        if (e) epreuvesSet.add(e);
        if (c) categoriesSet.add(c);
      });
      const epreuves = Array.from(epreuvesSet).sort();
      const categories = Array.from(categoriesSet).sort();

      // ---- calcul records pour chaque sexe ('Feminin'/'Masculin')
      function computeRecordsForSex(targetSexLabel) {
        // records[epreuve][categorie] = {nom, temps, sec}
        const records = {};
        epreuves.forEach(e => records[e] = {}); // initialise pour toutes épreuves
        data.forEach(row => {
          const epreuve = safeText(row[IDX_EPREUVE]);
          const sexeRaw = safeText(row[IDX_SEXE]);
          const sexe = normalizeSexFieldRaw(sexeRaw);
          const nom = safeText(row[IDX_NOM]);
          const temps = safeText(row[IDX_TEMPS]);
          const categorie = safeText(row[IDX_CATEG]) || '—';
          if (!epreuve) return;
          if (sexe !== targetSexLabel) return;
          const sec = parseTimeToSeconds(temps);
          if (!records[epreuve][categorie] || records[epreuve][categorie].sec > sec) {
            records[epreuve][categorie] = { nom, temps, sec };
          }
        });
        return records;
      }

      const recF = computeRecordsForSex('Feminin');
      const recM = computeRecordsForSex('Masculin');

      function makeRecordsTableHtml(records) {
        // si pas de categories (rare), afficher message
        if (!categories.length || !epreuves.length) return '<p class="no-records">Aucune donnée de records trouvée.</p>';
        let html = '<table class="csv-table"><thead><tr><th>Épreuve</th>';
        categories.forEach(cat => html += `<th>${cat}</th>`);
        html += '</tr></thead><tbody>';
        epreuves.forEach(ep => {
          html += `<tr><td style="text-align:left">${ep}</td>`;
          categories.forEach(cat => {
            const cell = (records[ep] && records[ep][cat]) ? records[ep][cat] : null;
            if (cell) html += `<td>${cell.temps}<br><small class="small">${cell.nom}</small></td>`;
            else html += '<td>—</td>';
          });
          html += '</tr>';
        });
        html += '</tbody></table>';
        return html;
      }

      document.getElementById('recordsFemmes').innerHTML = makeRecordsTableHtml(recF);
      document.getElementById('recordsHommes').innerHTML  = makeRecordsTableHtml(recM);

      // ---- activation des filtres sur tableau principal
      const filters = document.querySelectorAll('.colFilter');
      filters.forEach(select => {
        select.addEventListener('change', () => {
          const rows = document.querySelectorAll('#resultsTable tbody tr');
          rows.forEach(row => {
            let visible = true;
            filters.forEach(f => {
              const col = parseInt(f.dataset.col,10);
              const val = f.value;
              if (val && row.cells[col].textContent !== val) visible = false;
            });
            row.style.display = visible ? '' : 'none';
          });
        });
      });

    })
    .catch(err => {
      console.error('Erreur lecture CSV :', err);
      document.getElementById('tableContainer').textContent = 'Erreur lors du chargement des résultats.';
      document.getElementById('recordsFemmes').textContent = '';
      document.getElementById('recordsHommes').textContent = '';
    });
  </script>
</body>
</html>
